1.树是保证结点连通的边最少的方式
树是n个结点构成的有限集合 任意一个非空的数具备：
                        一个root 根结点
                        其余结点分为m个互不相交的有限集 T1,T2,.....Tm
                        每个集合很深也是一颗树，称为子树
                        
                        子树不相交；除了根结点，每个结点有且仅有一个父节点
                        一课N个结点的树有N-1条边

1.2.树的一些术语
   结点的度：结点的子树个数
   树的度：书中所有结点中最大的度数
   叶结点：度为0的结点
   父结点
   子结点
   兄弟结点:同一父结点
   路径和路径长度 ：路径包含的边的个数为长度
   祖先结点 ：树根到某一结点路径上所有结点
   子孙结点：
   结点的层次 根结点1层 其余是父结点+1
   树的深度：最大结点层次
  
1.3.树的表示：
儿子-兄弟表示法                 element
                       firstchild   nextsibling
二叉树的链表形式                       


2.1二叉树的定义
一个有穷的结点集合 可以为空
二叉树的子树有左右顺序之分
特别二叉树：斜二叉树
          完美二叉树 满二叉树
          完全二叉树 编号和满二叉树相同，即只缺最后一层后面的完美二叉树
          
2.2二叉树性质
 二叉树第i层最大结点数是 2 i-1次方
 任何非空二叉树T N0表示叶节点个数 N2表示度为2的非叶结点个数 满足
                N0=N2+1
                推导：二叉树总边数从下往上看 N0+N1+N2-1
                     从上往下看 0*N0+1*N1+2*N2
                     联立即可求解
 
2.3 二叉树的抽象数据类型定义
操作集：1.判断是否非空
        2.遍历     先序，中序，后续，层次遍历
        3.创建一个二叉树

2.3 二叉树的存储结构 
  (1):顺序存储结构  完全二叉树
                  i结点父亲：i/2取整 左儿子2i  右儿子 2i+1
  (2):链表存储  left data right
 
3.1二叉树的遍历
         A
   B          C
D     F     G      I
     E       H
（1）先序遍历：访问根节点；先序遍历左子树；先序遍历右子树
              ABDFECGHI
              递归的方法
（2）中序遍历 中序遍历左子树；访问根结点；中序遍历右子树
              DBEFAGHCI
(3):后序遍历  后序遍历左子树；后序遍历右子树；访问根结点
             DEFBHGICA
 注意：不管先序 中序 后续 经过结点路径相同，只是访问结点时机不同
 
 3.2 二叉树的非递归遍历
 （1）中序遍历非递归遍历算法：使用堆栈
 void InOrderTraversal(BinTree BT)
 { BinTree T=BT
   Stack S = CreatStack( MaxSize ); 创建并初始化堆栈S
   while(T || !IsEmpty(s)){
       while(T){   /* 一直向左并将沿途结点压入堆栈*/
           Push(S,T);
           T=T->Left;
           }
       if(!IsEmpty(S)){
           T=Pop(s);
           printf("%5d",T->Data);
           T = T->Right; /*转向右子树*/
           }
       }
   }
 }
 
 前序和后序方法类似
 
 3.3 层序遍历
 二叉树遍历核心问题：二维结构的线性化
 需要一个存储结构保存暂时不访问的结点
 存储结构：堆栈，队列
 
 队列实现：遍历从根结点开始，首先将根结点入队，然后开始执行循环：
               结点出队，访问该结点，其左右儿子入队
               ABCDFGIEH
 
 
3.4 遍历二叉树的应用：
（1）输出二叉树中的叶子结点
(2)求二叉树的高度
（3）由两种遍历序列确定二叉树 ：必须要有中序遍历才行

4.树的同构
给定两个树T1,T2  若T1经过若干次左右孩子交换可变成T2，称为同构

输入格式 ：输入2棵二叉树的信息
核心问题： 二叉树表示  建立二叉树  同构判别
二叉树表示：结构数组表示二叉树：静态链表
           填入左右孩子的位置

程序框架：建二叉树1    建二叉树：
         建二叉树2
         判断是否同构
         
         
