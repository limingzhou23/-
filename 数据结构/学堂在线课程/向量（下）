(d3)有序向量：Fibonacci查找  思路是多做向左侧的查找 因为左转比右转成本低 
            按照Fibonacci数来进行分割 若设n=fib(k)-1,可以取mi=fib(k-1)-1
                                    前后子向量长度为： fib(k-1)-1    fib(k-2)-1   左侧更大 整体得到优化
            为什么是最优的：实际上减治法的通用策略：对任何的A[0,n),总是选取A[xn]做轴点，0<x<1
                         二分查找x=0.5   Fibonacci对应于x=0.6180339  黄金分割
                         在[0,1)中，如何选择x 可以最优？
                         递推式：f(x)long2n=x[1+f(x)log2(xn)]+(1-x)[2+f(x)logx((1-x)n)]
                         可以求得x=0.618时  f(x)=1.44为最小值  （之前是1.50）

(d4)有序向量：二分查找（改进）
            改进思路：直接改变
                     每次迭代仅作1次关键码比较，仅保留两个分支。
                     1）e<x       若e存在，必然位于左侧S[lo,mi)
                     2）x<=e      若e存在，必然位于右侧S[mi,hi)
                     只有当元素数目hi-lo=1时，才确定命中
                     评价：最好情况变差，最差情况变好，算法趋于稳定
          语义约定：search()接口的语义约定：返回不大于e的最后一个元素           
          
          版本C:返回宽度为0的区间以便于插入，具体做法是在分支时分为：[lo,mi)  (mi,hi)，抛弃了中间那个元素，并且没有判断，
                                         因为只在乎这个元素两侧的缝隙
                                         相当于最后比对到某个分界，左侧都不大于e 右侧都大于e
                                         V[lo]此时是 min{0<=r<n|e<=V[r]}  仔细观察下标就可以
                                         取V[lo-1] 就是所需要的不大于e的最后一个元素
                     
                     
